
/*TX Module*/

tx_module {
    tx_queue_t transmit_queue(10);
    //TODO: add a simple next
}


/*Events*/

event SEND{
    int flow_id;
}

event ACK{
    int flow_id;
    list<int> pkt_nums;
    int largest;
    int ECT0_Count;
    int ECT1_Count;
    int ECN_CE_Count;
}

event TIMER{}

event ADD_DATA{
    bool server_side;
    bool direction;
    stream data;
}//handle stream ids based on section 2.1

event DATA_ARRIVAL{

    list<Frame> frames;
}

/*Scheduler*/

sched quicSched{

    queue_t<SEND> SEND_Queue(10,20,sendDrop);
    queue_t<ACK> ACK_Queue(10,20,ackDrop);
    queue_t<TIMER> TIMER_Queue(10,20,ackDrop);
    queue_t<ADD_DATA> ADD_DATA_Queue(10,20,ackDrop);

    bool sendDrop(queue_t add_queue, event_t new_event){
        return 0;
    }

    bool ackDrop(queue_t add_queue, event_t new_event){
        return 0;
    }

    bool enqueue(event_t new_event){
        if(type(new_event) == SEND){
            SEND_Queue.push(new_event)
            return 1;
        }else if(type(new_event) == ACK){
            ACK_Queue.push(new_event)
            return 1;
        }else if(type(new_event) == TIMER){
            TIMER_Queue.push(new_event)
            return 1;
        }else if(type(new_event) == ADD_DATA){
            ADD_DATA_Queue.push(new_event)
            return 1;
        }else if(type(new_event) == CONGESTION){
            CONGESTION_Queue.push(new_event)
            return 1;
        }
        return 0;
    }

    event_t next_event(){
        if(SEND_Queue.len()>0){
            return SEND_Queue.pop();
        }
        return ACK_Queue.pop();
    }
}


/*Context*/


struct QuicStream
{
    stream data;
    int id;
    int frame_size_limit;
    int last_sent;
    list<bool> acked_frames;
};

struct QuicStreamBuffer
{
    int id;
    stream data;
    int offset = 0;
    list<bool> received;
    addr_t address;

};

struct PacketInfo
{
    int packet_id;
    int time_sent;
    bool in_flight;
    bool ack_eliciting;
    int size;
    list<int> stream_id;
    list<int> frame_size;
    list<int> start_point;
}

struct Frame
{
    int data_length;
    int stream_id;
    int offset;
    stream data;
}


/*
initialize:
pto_count = 0
latest_rtt = 0
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
min_rtt = 0
first_rtt_sample = 0
for pn_space in [ Initial, Handshake, ApplicationData ]:
  largest_acked_packet[pn_space] = infinite
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0




*/

context MyContext
{
    list<QuicStream> streams;
    list<PacketInfo> sent_packets;
    int curr_idx;
    int size_limit;
    int MAX_STREAMS;
    int id_counter=0;
    int server_stream_counter=0;
    int client_stream_counter=0;
    int largest_acked_time=0;
    int packet_size_limit;

    //loss detection
    int kPacketThresh=3;
    int kTimeThreshold;
    int time_of_last_ack_eliciting_packet=0;
    int largest_acked_packet = -1;
    int kGranularity;
    //vars
    int pto_count = 0;
    int latest_rtt = 0;
    int smoothed_rtt;
    int rttvar;
    int min_rtt=0;
    int first_rtt_sample=0;
    int loss_time;

    bool update_rtt = false;
    //congestion
    int initialWindow = 14720;
    int minimumWindow;
    float lossReductionFactor = 0.5;
    int persistentCongestionThreshold = 3;

    int max_datagram_size;
    int bytes_in_flight=0;
    int congestion_window=0;
    int congestion_recovery_start_time=0;
    int ssthresh=-1;
    int ecn_ce_counters=0;



    //receiver:
    list<bool> recieved_packets;
    int r_largest_acked;

    list<QuicStreamBuffer> qsbs;

    int move_to_memory_size_thresh = 100;
    int max_stream_per_pkt  = 6;

}



header QuicHeader{
    int pkt_id;
}


/*Processors*/

void selectDataProcessor(SEND ev, MyContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out){
    int sent_size = 0;
    int i =0;
    pkt_t new_pkt = new_pkt();
    QuicStream qs;
    int bytes_allowed = ctx.congestion_window-ctx.bytes_in_flight;
    int bytes_in_packet = 
    int frame_size_limit = max(bytes_allowed/ctx.streams.size(),bytes_allowed/ctx.max_stream_per_pkt) 
    while(bytes_allowed>0){
        PacketInfo pkt_info;
        while(sent_size<ctx.size_limit && i < ctx.streams.len() && bytes_allowed>0 ){
            qs=ctx.streams[i];
            Frame frame;
            pkt_info.stream_id.add(i);
            frame.size = min(qs.frame_size_limit,bytes_allowed,frame_size_limit,qs.data.len()-qs.last_sent);
            pkt_info.frame_size.add(frame.size);
            pkt_info.start_point.add(qs.last_sent);
            frame.offset = qs.last_sent;
            frame.data = qs.data[qs.last_sent:qs.last_sent + frame.size];
            qs.last_sent = qs.last_sent + frame.size;
            //new_pkt.add_data(byte(frame));
            out.frames.add(frame);
            ctx.bytes_in_flight += frame.data.len();
            bytes_allowed-= frame.data.len();
            i+=1;
        }
    pkt_info.time_sent=now()
    QuicHeader qheader;
    qheader.pkt_id = ctx.id_counter++
    pkt_info.packet_id = qheader.pkt_id
    new_pkt.add_header(qheader)
    ctx.sent_packets.add(pkt_info)
    }
}

interm_output iterm_out {
    pkt_t packet;
    PacketInfo info;
    list<PacketInfo> lost_packets;
}

void sendProcessor<T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    if (info.in_flight){
        if (info.ack_eliciting)
            ctx.time_of_last_ack_eliciting_packet = now()
        if(timer.is_running)
            timer.restart(TIMER)
        else{
            timer.set_duration(ctx.kTimeThreshold)
            timer.start(TIMER)
        }
    }
    
}

void ackProcessor(ACK ev, MyContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    if (ctx.largest_acked_packet == -1)
        ctx.largest_acked_packet = ev.largest_acked
    else{
        ctx.largest_acked_packet = max(ctx.largest_acked_packet, ev.largest_acked)
    }
    bool new_packet_acked=false;
    list<PacketInfo> acked_packets;
    int acked_bytes;
    for(int i=0; i<ev.pkt_nums.len();i++){// change to for each
        for (int j=0; j<ctx.sent_packets.len();j++){
            if(i==ctx.sent_packets[j].packet_id){
                if(i == ctx.largest_acked_packet)
                    ctx.largest_acked_time = sent_packets[j].time_sent;
                acked_packets.add(ctx.sent_packets[j]);
                ctx.acked_bytes-=ctx.sent_packets[j].size;
                ctx.sent_packets.remove(ctx.sent_packets[j]);//chenge to remove(element)
                new_packet_acked=true;
                break;
            }
        }
    }
    ctx.bytes_in_flight -= acked_bytes;
    if(!new_packet_acked)
        return;

    ctx.latest_rtt = now() - ctx.largest_acked_time
    ctx.update_rtt = true;

    if(ack.ECN_CE_Count>ctx.ecn_ce_counters){
        ctx.ecn_ce_counters = ack.ECN_CE_Count;
        out.in_congestion = true;
        out.start_time = ctx.largest_acked_packet;
    }
}

void updateRttProcessor(ACK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {

    if(!ctx.update_rtt)
        return;
    ctx.update_rtt = false;
    if (ctx.first_rtt_sample == 0){
        ctx.min_rtt = ctx.latest_rtt;
        ctx.smoothed_rtt = ctx.latest_rtt;
        ctx.rttvar = ctx.latest_rtt / 2;
        ctx.first_rtt_sample = now();//     
        return;
    }

    ctx.min_rtt = min(ctx.min_rtt, ctx.latest_rtt)
    ctx.ack_delay = min(ctx.ack_delay, ctx.max_ack_delay)
    ctx.adjusted_rtt = ctx.latest_rtt
    if (ctx.latest_rtt >= ctx.min_rtt + ctx.ack_delay):
        ctx.adjusted_rtt = ctx.latest_rtt - ctx.ack_delay

    ctx.rttvar = 3/4 * ctx.rttvar + 1/4 * abs(ctx.smoothed_rtt - ctx.adjusted_rtt)
    ctx.smoothed_rtt = 7/8 * ctx.smoothed_rtt + 1/8 * ctx.adjusted_rtt

}

void adjustWindowProcessor<T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {

    for(pkt_t packet: out.acked_packets){
        if (packet.time_sent <= ctx.congestion_recovery_start_time)
            continue;
        if(ctx.congestion_window < ctx.ssthresh)
            ctx.congestion_window += packet.sent_bytes
        else
            ctx.congestion_window += ctx.max_datagram_size*packet.sent_bytes/ctx.congestion_window
    }
    if(ctx.congestion_window-ctx.bytes_in_flight>ctx.send_thresh){
        SEND ev;
        ev.fow_id = ctx.flow_id;
        events.add(ev);
    }
        
}

void congestionProcessor(CONGESTION ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {

    if (out.time_sent <= ctx.congestion_recovery_start_time||!out.in_congestion)
        return;

    ctx.congestion_recovery_start_time = now();
    ctx.ssthresh = ctx.congestion_window * ctx.lossReductionFactor;
    ctx.congestion_window = max(ctx.ssthresh, ctx.minimumWindow);

}

void lossDetectionProcessor<T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {

    list<PacketInfo> lost_packets;
    int loss_delay=ctx.kTimeThreshold;
    int loss_threshold = now()-loss_delay;
    int last_loss = 0;
    for (int i=0; i<ctx.sent_packets.len();i++){
        if(ctx.sent_packets[i].packet_id > ctx.largest_acked_packet)
            continue;
        if(ctx.sent_packets[i].time_sent > loss_threshold || ctx.largest_acked_packet >= ctx.sent_packets[i].packet_number + ctx.kPacketThreshold){
            lost_packets.add(ctx.sent_packets[i]);
            last_loss = max(ctx.sent_packets[i].sent_time,last_loss);
            ctx.sent_packets.remove(ctx.sent_packets[i]);
        }
    }

    out.lost_packets=lost_packets;
    if (lost_packets.len()>0){
        out.in_congestion = true;
        out.start_time = last_loss;
    }

}

void retransmitProcessor<T>(T ev, MyContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    if(out.lost_packets.len()==0){
        return;
    }
    for(int j=0; j<out.lost_packets.len()j++){
        PacketInfo lost_packet=out.lost_packets[j]
        pkt_t new_pkt = new_pkt();
        QuicStream qs;
        PacketInfo pkt_info = lost_packet;//copy by reference or value?
        for(int i=0; i<lost_packet.stream_id.len(); i++){
            QuicStream qs = ctx.streams[lost_packet.stream_id[i]];
            Frame frame;
            frame.size =lost_packet.frame_size[i]
            frame.data = qs.data[lost_packet.start_point[i]:lost_packet.start_point[i] + frame.size];
            new_pkt.add_data(byte(frame));
        }
        QuicHeader qheader;
        qheader.pkt_id = ctx.sent_packets.len()
        pkt_info.packet_id = qheader.pkt_id
        new_pkt.add_header()
        ctx.sent_packets.add(pkt_info)
        packets.add(new_pkt);//tx module instead of this
    }

}

void addStreamProcessor(ADD_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    QuicStream qs;
    if(ev.server_stream){
        qs.id=(ctx.server_stream_counter+=2)
    }else{
        qs.id=(ctx.client_stream_counter+=2)
    }
    qs.data=ev.data;
    SEND ev;
    ev.fow_id = ctx.flow_id;
    events.add(ev);
}

///////// RECEIVER


void storeDataProcessor(DATA_ARRIVAL ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.recieved_packets[ev.packet_id] = true;//add a seprate process for this
    if(ev.packet_id > ctx.r_largest_acked)
        ctx.r_largest_acked = ev.packet_id;     
    for(Frame frame: ev.frames){
        int curr_id = -1;
        for(int j=0;j<ctx.qsbs.size();j++){
            if(qsbs[j]== frame.stream_id){
                curr_id = j;
                break;
            }
        }
        if(curr_id==-1){//.creat new stream
            QuicStreamBuffer qsb;
            qsb.id = frame.stream_id;
            curr_id = frame.stream_id;
            qsbs.add(qsb);
        }

        for(int i =0; i<frame.data.size();i++){
            int buffer_idx = i + frame.offset - ctx.qsbs[curr_id].offset;
            ctx.qsbs[curr_id].data[buffer_idx]=frame[i];
            ctx.qsbs[curr_id].received[buffer_idx]= true;
        }
    }
}

void bufferManagerProcessor(DATA_ARRIVAL ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    for(int i = 0;i<qsbs.size();i++){
        int size = 0;
        while(qsbs[i].received[size]!=false)//.calculates the size of in order data
            size++;
        if(size >= ctx.move_to_memory_size_thresh){
            mem_write(qsbs[i].address, qsbs[i].data[0:size], qsbs[i].offset, size);
            qsbs[i].data=qsbs[i].data[size:-1];//Question: is this (-1) allowed? Answer: no, keep the end in a seprate var
            qsbs[i].offset += size;
        }
    }

}

struct AckRange{
    int gap;
    int ack_range_length;
}

struct ackFrame{
    int type = 2;
    int largest_acked;
    float ack_delay;
    int range_count;
    int first_ack_range;
    list<AckRange> ack_ranges;
    int ecn_count;
}

void ackGenerationProcessor(DATA_ARRIVAL ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ackFrame frame;
    if(!out.ack_eliciting){
        return;
    }
    frame.largest_acked = ctx.largest_acked;
    int i = ctx.largest_acked-1;
    int count=0;
    while(ctx.recieved_packets[i]&&i>=0)
        count++;
    frame.first_ack_range = count;
    bool count_gap=true;
    AckRange range;
    count=0;
    for(int j=i;j>=0;j--){
        if(count_gap && ctx.recieved_packets[j] == true){
            range.gap = count;
            count = 1;
            count_gap = false;
        }else if(!count_gap && ctx.recieved_packets[j] == false){
            range.ack_range_length = count;
            frame.ack_ranges.add(range);
            range = new AckRange;
            count = 1;
            count_gap = true;
        }else{
            count++;
        }
    }
    if(count_gap){
        range.gap = count;
    }else{
        range,ack_range_length = count;
    }
    frame.ack_ranges.add(range);

    out.frames.add(frame);

}

//TODO: add MAX_BUFFER_SIZE.
//TODO: add RX_MODULE based on the example.

void packetGenerationProcessor(DATA_ARRIVAL ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    pkt_t new_pkt = new_pkt();
    for(Frame frame: out.frames){
        new_pkt.add_data(byte(frame));
    }
    PacketInfo pkt_info
    pkt_info.time_sent=now()
    QuicHeader qheader;
    qheader.pkt_id = ctx.id_counter++
    pkt_info.packet_id = qheader.pkt_id
    new_pkt.add_header(qheader)
    ctx.sent_packets.add(pkt_info)
    tx_module.add(new_pkt);// pick a queue to add a packet   
}

/*Dispatch Table*/

dispatch table{
    //SENDER
    SEND -> {selectDataProcessor, sendProcessor, packetGenerationProcessor}
    ACK -> {ackProcessor ,congestionProcessor,updateRttProcessor,lossDetectionProcessor, congestionProcessor,  adjustWindowProcessor, retransmitProcessor, packetGenerationProcessor}
    TIMER -> {lossDetectionProcessor,congestionProcessor,retransmitProcessor, packetGenerationProcessor}
    ADD_DATA -> {addStreamProcessor}
    //RECEIVER
    DATA_ARRIVAL -> {storeDataProcessor, bufferManagerProcessor, ackGenerationProcessor, packetGenerationProcessor}
}
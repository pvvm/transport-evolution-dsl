scheduler_t scheduler {

    event_t APP {
        int connection_id;
        int advertized_window;
        int seq_number;
    };

    // is parameter event_t necessary?

    int app_drop(queue_t app_queue, APP new_event) {
        int index = -1;
        int counter = 0;
        int smallest_size = 0;


        foreach app_event in app_queue {
            if(app_event.advertized_window < smallest_size) {
                smallest_size = app_event.advertized_window;
                index = counter;
            }
            counter = counter + 1;
        }
        
        // some sort of index for queues?
        // would the new event be a parameter?

        if(index != -1) {
            app_queue[index] = new_event;
        }

        //what would we return?

        return 0;
    }
    
    // is minimum length necessary?

    queue_t <APP> app_queue(1, 3, 10, app_drop);


    event_t ACK {
        int connection_id;
        int advertized_window;
        int ack_number;
        int seq_number;
    };

    int ack_drop(queue_t ack_queue, event_t ACK) {

        // add an operation to return the size of a queue?
        len(ack_queue);

        int index = 0;
        foreach ack_event in ack_queue:
            index = index + 1;

        return 0;
    }

    queue_t <ACK> ack_queue(2, 3, 10, ack_drop);


    // why event_t?
    // what would go in this function? is there any necessity to change enqueue?
    bool enqueue(event_t e) {
    }

    // maybe we could let the programmer declare the priority here
    // or some sort of function
    event_t next_event() {
        if(len(app_queue) > app_queue.maxLen / 2) {
            return type(app_queue);
        } else {
            return type(ack_queue);
        }
    }
}

dispatch_table_t table = {
    APP -> {CongestionProcessor, SendProcessor};
    ACK -> {ACKProcessor};
};

processor_t CongestionProcessor(event_t event) {
    // some sort of way to access the context? dictionary? connection_id like a list?
    int diff = context.last_byte_sent - context.last_byte_acked;

    int effect_window = context.advertized_window - diff;

    if(effect_window > 0) {
        // proceeds to SendProcessor
        
    } else {
        // what should it do? drop or push back to events queue?
    }
}

processor_t SendProcessor(event_t event) {
    // some special instruction to send?
}

processor_t ACKProcessor(event_t event) {
    int compare_ack = context.last_seq_sent + context.last_segm_length;


    if(compare_ack != event.ack_number) {
        // retransmit? push new event?
    } else {
        // update informations in context?
    }
}

// is context shared among events of the same type?
// or one context for each connection? -> connection_id could be an index?
context_t context {
    int connection_id;
    int advertized_window;
    int last_seq_sent;
    int last_segm_length;
    int last_byte_sent;
    int last_byte_acked;
}
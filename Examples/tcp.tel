// tcp header

sched myScheduler {

    event SEND {
        int time;
        int flow_id;
    }

    int send_drop(queue_t send_queue, SEND new_event) {
        int most_recent = 0;
        int index = 0;
        int counter = 0;

        foreach event in send_queue {
            if(event.time > most_recent) {
                most_recent = event.time;
                index = counter;
            }
            counter = counter + 1;
        }

        return index;
    }

    queue_t <SEND> send_queue(10, 20, send_drop);


    event ACK {
        int flow_id;
        int acknum;
    }

    int ack_drop(queue_t ack_queue, ACK new_event) {
        int index = len(ack_queue) - 1;

        return index;
    }

    queue_t <ACK> ack_queue(5, 15, ack_drop);

    event TIMER {
        int flow_id;
    }


    int timer_drop(queue_t ack_queue, TIMER new_event) {
        int index = len(ack_queue) - 1;

        return index;
    }

    queue_t <TIMER> timer_queue(3, 10, timer_drop);
// each queue's event with its own enqueue

    // maybe add new_event and enqueue events?
    bool enqueue(event new_event) {

        if (type(new_event) == SEND) {
            send_queue.push(new_event);
            return 1;
        }
        if (type(new_event) == ACK) {
            ack_queue.push(new_event);
            return 1;
        }
        if (type(new_event) == TIMER) {
            timer_queue.push(new_event);
            return 1;
        }
        return 0;
    }

    // add queues as parameters?
    event_t next_event() {
        if(len(timer_queue) > len(ack_queue) / 2) {
            return TIMER;
        }
        if (len(send_queue) < len(ack_queue)) {
            return ACK;
        }
        return TIMER;
    }
}

dispatch table {
    SEND -> {SendProcessor};
    ACK -> {ACKProcessor};
    TIMER -> {TIMERProcessor};
}

// change to packet_t

struct proc_out_t {
    list<event_t> event_list;
    list<segment_t> segment_list;
}

proc_out_t SendProcessor(SEND event, myContext context) {
    proc_out_t output;

    // why 128?
    for(;
    (context.m_Nxt < context.m_Una + context.m_Nxt) && (context.m_Nxt < 128);
    context.m_Nxt = context.m_Nxt + context.m_segmentsize) {
        

        // and now time?

    }
    output.event_list.add(SEND)
	output.segment_list.add();

    return output;
}


proc_out_t ACKProcessor(ACK event, myContext context) {
    
    // isResend is a map. How to represent it in our language?
    
    // some variables are float

    output.event_list.add(ACK);
	output.segment_list.add();

    return output;
}

proc_out_t TIMERProcessor(TIMER event, myContext context) {

    if (context.m_Una < 128) {
        if (context.m_Wnd / 2 >= 1) {
            context.m_Wnd = context.m_Wnd / 2;
        } else {
            context.m_Wnd = 1;
        }

    }

    output.event_list.add(TIMER);
	output.segment_list.add();

    return output;
}


context myContext {
    int m_Una;
    int m_Nxt;
    int m_start;
    int m_Wnd;
    int m_Iss;
    int Smss;
    int m_dupSeq;
    int m_dupAmount;
    int m_cnwd;
    int m_ssthresh;
    int m_segmentsize;
    int m_dupThreshold;
}
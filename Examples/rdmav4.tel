// Note: revisit priorities, since the number of events exploded

// A: the runtime will automatically do the rate limiting

// A: rx_module will look like a p4 parser

// A: transmit_queue.rate() to set the rate of the transmit queue

event RDMA_EVENT {
    int wr_id;
    int lkey;
    addr_t addr;
    int length;
}

event SEND_WQE : RDMA_EVENT {
    int ack_req;
}

event WRITE_WQE : RDMA_EVENT {
    int ack_req;
    int rkey;
    addr_t raddr; 
}

event READ_WQE : RDMA_EVENT {
    int rkey;
    addr_t raddr; 
}

// Note: Atomic operations use 64 bit fields
// A: bit<n> in headers
event ATOMIC_WQE : RDMA_EVENT {
    int swap_add;
    int compare;
    int rkey;
    addr_t raddr;
}

event RECV_WQE : RDMA_EVENT {

}

event TRANSMIT_EVENT {
    int qp_id;
    int wr_id;
    int psn;
    bool ack_req;
}

event ACK {
    int qp_id;
    int wr_id;
    // everything prior and including this number is received
    int psn; 
    int credit_count;
    int MSN;
}

event NACK {
    int qp_id;
    int wr_id;
    bool type_nack;
    int psn;
    float RNR_delay;
}

event READ_REQ_DATA {
    int qp_id;
    int wr_id;
    int psn;
    addr_t raddr;
    int rkey;
    bool ecn;
}

event READ_RESP_DATA {
    int qp_id;
    int wr_id;
    int psn;
    stream data;
}

event WRITE_DATA {
    int qp_id;
    int wr_id;
    int psn;
    bool ack_req;
    addr_t raddr;
    int rkey;
    int length;
    bool ecn;
    stream data;
}

event RECV_DATA {
    int qp_id;
    int wr_id;
    int psn;
    bool ack_req;
    stream data;
    int opcode;
    bool ecn;
}

event ATOMIC_DATA {
    int qp_id;
    int swap_add;
    int compare;
    int rkey;
    addr_t raddr;
    bool ecn;
}

event CNP_CHECK {
    int qp_id;
}

event CNP {
    int qp_id;
}

event DCQCN_TIMER {
    int qp_id;
}

event DCQCN_INCREASE {
    int qp_id;
}

event ALPHA_CHECK {
    int qp_id;
}

event TX_THRESHOLD {
    int flow_id;
    int tx_queue_id;
}

event TX_TIMER {
    int flow_id;
    int timer_id;
}

event TX_QUEUE_FULL {
    int flow_id;
    int tx_queue_id;
}

interm_output iterm_out {
}

struct work_comp {
    int wr_id;
    int status;
    int opcode;
    int qp_id;
    int length;
}

header UDPHeader {
    int src_port;
    int dst_port;
    int length;
    int checksum;
}

header BTHeader {
    int opcode;
    bool ack_req;
    int dest_qp;
    int psn;
}

header RETHeader {
    int raddr;
    int rkey;
    int length;
}

header AETHeader {
    // Note: syndrome is represented as a binary originally. Perhaps we should have a way to represent binary numbers
    // For now, I'll split it in 2 bools and 1 int
    bool ack;           // 1 if ack, 0 if nack
    bool type_nack;     // 1 if OOO, 0 if RNR
    // TODO: implement the credit count/msn system for send operations
    int credit_count;
    int MSN;
    float RNR_delay;
}

header AtomicETHeader {
    addr_t raddr;
    int rkey;
    int swap_add;
    int compare;
}

header AtomicAckETHeader {
    int original_data;
}

struct packet_list {
    pkt_t packet;
    int psn;
    bool ack_req;
    int wr_id;
    bool acked;
}

context myContext {
    int qp_id;
    int lkey;
    list<RDMA_EVENT> SQ_list;
    list<RDMA_EVENT> RQ_list;
    list<packet_list> sent_packets;
    int nPSN;
    int transport_timer;
    stream CQ;

    // Responder side
    int ePSN;
    int MSN;
    int credit_count;
    int recv_first_psn;
    int write_first_psn;

    int MTU;
    int init_sqn;
    int dest_qp;
    int src_port;
    int dst_port;

    // DCQCN
    int Rt;
    int Rc;
    int alpha;
    int byte_counter;
    int BC;
    int T;
    int F;
    int Rai;

    // Note: can we assign a initial value for the variables of the context?
    // A: yes
    bool first_pkt_connection = true;

    // TX queue
    tx_out_t tx_feedback;
    list<event_t> events0;
    list<event_t> events1;
    // Note: can we define a variable number of timers? In this case, each for a tx_queue
    // Maybe we could use a list of timers. But this wouldn't work, since we only push and pop elements from the list
    // and we need to access the elements in the list according to the qp_id/flow
    // list<timer_t> tx_timers[2];

    timer_t tx_timer0;
    timer_t tx_timer1;

    // Timers
    timer_t timer_ack_timeout;
    timer_t timer_cnp;
    timer_t timer_alpha;
    timer_t timer_DCQCN_counter
}

pkt_sched tx_module {
    // Note: it seems that the minimum length and drop function won't matter for this kind of queue
    // should we keep only the maximum length?
    // A: just length
    tx_queue_t transmit_queue()[2];

    int packet_counter = 0;
    int currently_sending = 0;

    pkt_t next_packet() {
        int slice = 10;
        pkt_t p = transmit_queue[currently_sending].pop();
        packet_counter = packet_counter + 1;

        if(packet_counter == slice || transmit_queue[currently_sending].len() == 0) {
            currently_sending = (currently_sending + 1) % 2;
            packet_counter = 0;
        }

        return p;
    }
}

event_sched rx_module {
    // New note: P4 utilizes state machines, extracting the header and, based on its value, sending to the
    // next state. In our case, I guess we don't need one, since the events are quite abstract and a single opcode
    // can represent a type of event.
    // But would this also be the case for other protocols?

    // New note: the type of events from packets we expect to receive from the IP layer:
    // ACK NACK READ_REQ_DATA READ_RESP_DATA WRITE_DATA RECV_DATA ATOMIC_DATA

    // New note: meanwhile, for the events comming from the application should we assume that the events are
    // generated automatically?

    event_t packet_parser(pkt_t packet) {
        // New note: when using get_hdr, can we assume that we can use the same id used in add_hdr?
        // The header itself kind of gets an id when we add it to the packet.
        // Or we could just to a series of get_hdr without the id, returning udp, bth and eth, respectivelly
        BTHeader bth = packet.get_hdr(bth);

        int op = bth.opcode;

        // New note: we don't have switch. It could be more elegant, but if/elses can do the same
        
        if(op == 4 || op == 0 || op == 2 || op == 1) {
            RECV_DATA new_event;

            // New note: our packets do not have wr_id in their headers. Maybe the psn could uniquely represent an wr, at least in a given qp
            // new_event.wr_id;

            new_event.qp_id = bth.dest_qp;
            new_event.psn = bth.psn;
            new_event.ack_req = bth.ack_req;
            new_event.data = packet.get_data();
            new_event.opcode = bth.opcode;

            // New note: how can we get ecn from ipv4 header?
            new_event.ecn;
            return new_event;

        } else if(op == 10 || op == 6 || op == 8 || op == 7) {
            RETHeader reth = packet.get_hdr(reth);
            WRITE_DATA new_event;
            new_event.qp_id = bth.dest_qp;
            //new_event.wr_id;
            new_event.psn = bth.psn;
            new_event.ack_req = bth.ack_req;
            new_event.raddr = reth.raddr;
            new_event.rkey = reth.rkey;
            new_event.length = reth.rkey;
            //new_event.ecn;
            new_event.data = packet.get_data();
            return new_event;

        } else if(op == 12) {
            RETHeader reth = packet.get_hdr(reth);
            READ_REQ_DATA new_event;
            new_event.qp_id = bth.dest_qp;
            //new_event.wr_id;
            new_event.psn = bth.psn;
            new_event.raddr = reth.raddr;
            new_event.rkey = reth.rkey;
            //new_event.ecn;
            return new_event;

        } else if(op == 20 || op == 19) {
            AtomicAckETHeader atomicAeth = packet.get_hdr(atomicAeth);
            ATOMIC_DATA new_event;
            new_event.qp_id = bth.dest_qp;
            new_event.swap_add = atomicAeth.swap_add;
            new_event.compare = atomicAeth.compare;
            new_event.rkey = atomicAeth.rkey;
            new_event.raddr = atomicAeth.raddr;
            //bool ecn;
            return new_event;

        // Common ack/nack or atomic ack
        } else if(op == 17 || op == 18) {
            AETHeader aeth = packet.get_hdr(aeth);
            if(aeth.ack || op == 18) {
                ACK new_event;
                new_event.qp_id = bth.dest_qp;
                //new_event wr_id;
                new_event.psn = bth.psn;
                new_event.credit_count = aeth.credit_count;
                new_event.MSN = aeth.MSN;
                return new_event;
            } else {
                NACK new_event;
                new_event.qp_id = bth.dest_qp;
                //new_event wr_id;
                new_event.psn = bth.psn;
                new_event.type_nack = aeth.type_nack;
                new_event.RNR_delay = aeth.RNR_delay;
                return new_event;
            }

        } else if(op == 16 || op == 13 || op == 15 || op == 14) {
            READ_RESP_DATA new_event;
            new_event.qp_id = bth.qp_id;
            //int wr_id;
            new_event.psn = bth.psn;
            new_event.data = packet.get_data();
            return new_event;
        }

        // New note: if it doesn't match any opcode, what should we return?
        // Instead, the function could return void and we simply push to the type's queue.
        // Problem: this function would need to be inside of the scheduler to access the queues
    }

}


sched ROCEv2Sched {

    int repeat_drop(queue_t TIMER_Queue) {
        return 0;   // always drops the first packet of the queue
    }

    queue_t<RDMA_EVENT> SEND_Queue();
    queue_t<RDMA_EVENT> RECV_Queue();
    queue_t<RATE_TIMER> TIMER_Queue(0, 1, repeat_drop);
    queue_t<ACK> ACK_Queue();
    queue_t<NACK> NACK_Queue();

    
    

    bool enqueue(event_t new_event) {
        if(type(new_event) == RDMA_EVENT::SEND_WQE ||
        type(new_event) == RDMA_EVENT::WRITE_WQE ||
        type(new_event) == RDMA_EVENT::READ_WQE) {
            SEND_Queue.push(new_event);
            return 1;
        } else if(type(new_event) == RDMA_EVENT::RECV_WQE) {
            RECV_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == RATE_TIMER) {
            TIMER_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == ACK) {
            ACK_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == NACK) {
            NACK_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == CNP) {
            CNP_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == DATA) {
            DATA_Queue.push(new_event);
            return 1;
        }
        return 0;
    }


    // Note: priority
    // A: NACK / CNP (TIMER vs ACK) DATA / RDMA_EVENT
    // NACK / ACK TIMER DATA / RDMA_EVENT
    // Check round robin (deficit and weighted) vs. Aging

    // Note: active() returns false if the queue if empty or paused, true otherwise
    // Instead of having a list of events/packets in the context that receives new elements for
    // a certain period of time (using timer operations), could we have a pause() function?
    // It might be a bit too abstract, but having a function that pauses the scheduler sending
    // new events of a type for a given amount of time might be handy
    // A: the runtime will do this part of detecting if it should pause or not.
    // But having a pause() could still be interesting
    event_t next_event() {
        // Note: since TRANSMIT_EVENT is the only event that really sends packets, it would be
        // only EP we would use pause()
        if(!NACK.active()) {
            return NACK_Queue.pop();
        } else
            ...
    }
}

void SendProcessor(RDMA_EVENT::SEND_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.SQ_list.add(ev);

    if(ev.lkey == ctx.lkey) {
        stream buffer;
        buffer.mem_append(ev.addr, ev.length);
        int first_psn;

        for(int index = 0; index < ev.length; index = index + ctx.MTU) {
            pkt_t p = new_pkt();

            int data_len = ctx.MTU;
            if(index + ctx.MTU < ev.length)
                p.add_data(buffer[index : index + ctx.MTU]);
            else { // if the last packet doesn't match MTU
                p.add_data(buffer[index : ev.length]);
                data_len = env.length - index;
            }

            BTHeader bth;
            if(ev.length <= ctx.MTU) {
                bth.opcode = 4;     // only 1 packet
                last_packet = true;
                first_psn = ctx.nPSN;
            } else if(index == 0) {
                bth.opcode = 0;     // first packet
                first_psn = ctx.nPSN;
            } else if(index + ctx.MTU >= ev.length)
                bth.opcode = 2;     // last packet
            else
                bth.opcode = 1;     // middle packet
            bth.ack_req = ev.ack_req;
            bth.dest_qp = ctx.dest_qp;
            bth.psn = ctx.nPSN;
            ctx.nPSN = ctx.nPSN + 1;

            UDPHeader udp;
            udp.src_port = ctx.src_port;
            udp.dst_port = ctx.dst_port;
            udp.length = 8 + bth.len() + data_len;
            // checksum(name_of_the_algorithm)

            p.add_dr({udp, bth});

            packet_list save_packet;
            // Note: could assign work from one packet to another? or should we have a copy function?
            save_packet.packet = p;
            save_packet.psn = bth.psn;
            save_packet.ack_req = bth.ack_req;
            save_packet.wr_id = ev.wr_id;
            save_packet.acked = false;
            ctx.sent_packets.add(save_packet);
            packets.add(p);
        }
        TRANSMIT_EVENT new_event;
        new_event.wr_id = ev.wr_id;
        new_event.psn = first_psn;
        new_event.ack_req = ev.ack_req;
        events.add(new_event);
    }
}

void WriteProcessor(RDMA_EVENT::WRITE_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.SQ_list.add(ev);

    if(ev.lkey == ctx.lkey) {
        stream buffer;
        buffer.mem_append(ev.addr, ev.length);
        RETHeader reth;
        int first_psn;

        for(int index = 0; index < ev.length; index = index + ctx.MTU) {
            pkt_t p = new_pkt();

            int data_len = ctx.MTU;
            if(index + ctx.MTU < ev.length)
                p.add_data(buffer[index : index + ctx.MTU]);
            else { // if the last packet doesn't match MTU
                p.add_data(buffer[index : ev.length]);
                data_len = ev.length - index;
            }

            if(index == 0) {
                reth.raddr = ev.raddr;
                reth.rkey = ev.rkey;
                reth.length = ev.length;
            }

            BTHeader bth;
            if(ev.length <= ctx.MTU) {
                bth.opcode = 10;     // only 1 packet
                first_psn = ctx.nPSN;
            } else if(index == 0) {
                bth.opcode = 6;     // first packet
                first_psn = ctx.nPSN;
            } else if(index + ctx.MTU >= ev.length)
                bth.opcode = 8;     // last packet
            else
                bth.opcode = 7;     // middle packet
            bth.ack_req = ev.ack_req;
            bth.dest_qp = ctx.dest_qp;
            bth.psn = ctx.nPSN;
            ctx.first_psn = ctx.nPSN;
            ctx.nPSN = ctx.nPSN + 1;

            UDPHeader udp;
            udp.src_port = ctx.src_port;
            udp.dst_port = ctx.dst_port;
            udp.length = 8 + bth.len() + data_len;
            if(index == 0) {
                udp.length = udp.length + eth.len();
                p.add_hdr({udp, bth, reth});
            } else
                p.add_hdr({udp, bth});

            packet_list save_packet;
            // Note: could assign work from one packet to another? or should we have a copy function?
            save_packet.packet = p;
            save_packet.psn = bth.psn;
            save_packet.ack_req = bth.ack_req;
            save_packet.wr_id = ev.wr_id;
            save_packet.acked = false;
            ctx.sent_packets.add(save_packet);
            packets.add(p);
        }
        TRANSMIT_EVENT new_event;
        new_event.wr_id = ev.wr_id;
        new_event.psn = first_psn;
        new_event.ack_req = ev.ack_req;
        events.add(new_event);
    }
}

void RecvProcessor(RDMA_EVENT::RECV_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.RQ_list.add(ev);
    ctx.credit_count = ctx.credit_cout + 1;
}

void ReadProcessor(RDMA_EVENT::READ_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.SQ_list.add(ev);

    pkt_t p = new_pkt();
    int first_psn;

    RETHeader reth;
    reth.raddr = ev.raddr;
    reth.rkey = ev.rkey;
    reth.length = ev.length;

    BTHeader bth;
    bth.opcode = 12;
    bth.dest_qp = ctx.dest_qp;
    bth.psn = ctx.nPSN;
    first_psn = ctx.nPSN;
    // Note: maybe we'll need a floor/ceiling function or % to get the remainder of the division
    // A: use int()
    // A: also add % (remainder)
    ctx.nPSN = ctx.nPSN + ceil(ev.length / ctx.MTU);

    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len() + eth.len();

    p.add_hdr({udp, bth, eth});

    for(int i = 0; i < ceil(ev.length / ctx.MTU); i = i + 1) {
        packet_list save_packet;
        // Note: could assign work from one packet to another? or should we have a copy function?
        save_packet.packet = p;
        save_packet.psn = bth.psn + i;
        save_packet.ack_req = true;
        save_packet.wr_id = ev.wr_id;
        save_packet.acked = false;
        ctx.sent_packets.add(save_packet);
    }
    // make sure to not retransmit the same packet
    TRANSMIT_EVENT new_event;
    new_event.wr_id = ev.wr_id;
    new_event.psn = first_psn;
    new_event.ack_req = ev.ack_req;
    events.add(new_event);
}

void AtomicProcessor(RDMA_EVENT::READ_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.SQ_list.add(ev);

    pkt_t p = new_pkt();
    int first_psn;

    AtomicETHeader aeth;
    aeth.raddr = ev.raddr;
    aeth.rkey = ev.rkey;
    aeth.swap_add = ev.swap_add;
    aeth.compare = ev.compare;
    p.add_hdr(aeth);

    BTHeader bth;
    // Note: is it ok if I consider that for fetchAdd operations aeth.compare will be -1? (Or some other value)
    // Because aeth necessarily takes compare, even if it is a fetchAdd operation
    // A: yes
    if(aeth.compare == -1)  // fetchAdd
        bth.opcode = 20;
    else                    // compSwap
        bth.opcode = 19;
    bth.dest_qp = ctx.dest_qp;
    bth.psn = ctx.nPSN;
    ctx.nPSN = ctx.nPSN + 1;

    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len() + aeth.len();

    p.add_hdr({udp, bth, aeth});
    packet_list save_packet;
    // Note: could assign work from one packet to another? or should we have a copy function?
    save_packet.packet = p;
    save_packet.psn = bth.psn + i;
    save_packet.ack_req = true;
    save_packet.wr_id = ev.wr_id;
    save_packet.acked = false;
    ctx.sent_packets.add(save_packet);

    TRANSMIT_EVENT new_event;
    new_event.wr_id = ev.wr_id;
    new_event.psn = ctx.nPSN - 1;
    new_event.ack_req = true;
    events.add(new_event);
}

void TransmitProcessor(TRANSMIT_EVENT ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {

    int sent_packets = 0;
    bool last_packet = true;
    int threshold = 5;

    for(packet in ctx.packet_list) {
        if(packet.psn >= ctx.first_psn) {
            ctx.tx_feedback = tx.transmit_queue[tx_queue_number].push(packet);

            if(ctx.tx_feedback.spaces_left > threshold) {
                sent_packets = sent_packets + 1;
                packets.add(packet);

                // Note: increase byte counter for DCQCN
                ctx.byte_counter = packet.len();
                if(ctx.byte_counter > ctx.B) {
                    ctx.byte_counter = 0;
                    ctx.BC = ctx.BC + 1;

                    DCQCN_INCREASE new_event;
                    new_event.qp_id = ev.qp_id;
                    events.add(new_event);
                }
            } else {
                last_packet = false;
                break;
            }
        }
    }

    if(!last_packet && ctx.tx_feedback.able) {
        TRANSMIT_EVENT new_event;
        new_event.wr_id = ev.wr_id;
        new_event.psn = ev.psn + sent_packets;
        new_event.ack_req
        events.add(new_event);
    }

    if(ev.ack_req) {
        ctx.timer_ack_timeout.set_duration(microsecond(ctx.transport_timer));
        ctx.timer_ack_timeout.start(ev);
    }

    // New note: I think that it would make sense to set the rate in EPs that change the current rate (Rc), such
    // as CnpProcessor and DcqcnIncreaseProcessor. But only EPs that send packets to the TX_module have access to the
    // TX_module
    
    // New note: does each transmit queue have its own transmission rate?
    // if so, how can we distinguish the tx_queue for the current qp? e.g. tx.transmit_queue[0 or 1].rate(...)
    // if not, how can other connections affect the others? how can we receive rate updates from its peers? 
    tx.rate(ctx.Rc);
}

void RecvDataProcessor(RECV_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    pkt_t p = new_pkt();

    if(ctx.credit_count > 0) {
        if(ev.psn == ctx.ePSN && ev.opcode == 0 || ev.opcode == 4) {        // saves the psn of send operation's first packet
            ctx.recv_first_psn = ev.psn;
        }
        AETHeader aeth;
        if(ev.psn <= ctx.ePSN) {        // duplicate or expected PSN
            aeth.ack = true;
            aeth.MSN = ctx.MSN;
            if(ev.psn == ctx.ePSN && ev.opcode == 2 || ev.opcode == 4)        // last or only packet
                ctx.credit_count = ctx.credit_count - 1;
            aeth.credit_count = ctx.credit_count;
        } else {                        // out-of-order: NACK
            aeth.ack = false;
            aeth.type_nack = true;
        }
        BTHeader bth;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});

        if(ev.psn == ctx.ePSN) {
            ctx.ePSN = ctx.ePSN + 1;
            addr_t addr = ctx.RQ_list[0].addr;
            mem_write(addr, ev.data, ev.psn - ctx.recv_first_psn, ev.data.len());

            if(ev.opcode == 2 || ev.opcode == 4) {
                work_comp cqe;
                cqe.wr_id = ev.wr_id;
                cqe.status = 0;
                cqe.opcode = 6;
                cqe.qp_id = ev.qp_id;
                cqe.length = ev.data.len();
                ctx.CQ.add(byte(cqe));

                // Note: actually, we don't have an operation to remove elements from a list
                // Maybe we could use the following sintax, which always remove the first element of the list
                // A: use pop
                // Note: we are currently using add to add something to the end of a list. Should we start using push, then?
                // A: yes (add/remove or push/pop for packets, lists and streams)
                // check vectors
                ctx.RQ_list.pop();
            }
        }
        if(ev.ack_req || !aeth.ack)     // sends packet if requires ack or is a nack
            packets.add(p);

        

    } else {                // there are no recv events posted
        AETHeader aeth;
        aeth.ack = false;
        aeth.type_nack = false;
        BTHeader bth;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    }
}

void WriteDataProcessor(WRITE_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    if(ev.psn == ctx.ePSN && ev.opcode == 6 || ev.opcode == 10) {        // saves the psn of write operation's first/only packet
        ctx.write_first_psn = ev.psn;
    }
    AETHeader aeth;
    if(ev.psn <= ctx.ePSN) {        // duplicate or expected PSN
        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;
    } else {                        // out-of-order: NACK
        aeth.ack = false;
        aeth.type_nack = true;
    }
    BTHeader bth;
    bth.opcode = 17;
    bth.dest_qp = ctx.dest_qp;
    bth.psn = ctx.ePSN;
    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len() + aeth.len();
    p.add_hdr({udp, bth, aeth});

    if(ev.psn == ctx.ePSN) {
        ctx.ePSN = ctx.ePSN + 1;
        addr_t addr = ctx.RQ_list[0].addr;
        mem_write(addr, ev.data, ev.psn - ctx.write_first_psn, ev.data.len());
    }
    if(ev.ack_req || !aeth.ack)     // sends packet if requires ack or is a nack
        packets.add(p);
}

void ReadReqProcessor(READ_REQ_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    pkt_t p = new_pkt();

    AETHeader aeth;
    BTHeader bth;
    if(ev.psn == ctx.ePSN) {        // expected PSN
        stream buffer;
        buffer.mem_append(ev.raddr, ev.length);
        bool last_packet = false;

        for(int index = 0; index < ctx.length; index = index + ctx.MTU) {
            int data_len = ctx.MTU;
            if(index + ctx.MTU < ev.length)
                p.add_data(buffer[index : index + ctx.MTU]);
            else { // if the last packet doesn't match MTU
                p.add_data(buffer[index : ev.length]);
                data_len = ev.length - index;
            }
            aeth.ack = true;
            aeth.MSN = ctx.MSN;
            aeth.credit_count = ctx.credit_count;
            if(ev.length <= ctx.MTU) {
                bth.opcode = 16;     // only 1 packet
                last_packet = true;
            } else if(index == 0)
                bth.opcode = 13;     // first packet
            else if(index + ctx.MTU >= ev.length) {
                bth.opcode = 15;     // last packet
                last_packet = true;
            } else
                bth.opcode = 14;     // middle packet
            bth.dest_qp = ctx.dest_qp;
            bth.psn = ctx.ePSN;
            UDPHeader udp;
            udp.src_port = ctx.src_port;
            udp.dst_port = ctx.dst_port;
            if(bth.opcode != 14) {
                udp.length = 8 + bth.len() + aeth.len() + data_len;
                p.add_hdr({udp, bth, aeth});
            }
            else {
                udp.length = 8 + bth.len() + data_len;
                p.add_hdr({udp, bth});
            }

            // create a EP for the responder side (transmit/retransmit)

            packets.add(p);
            ctx.ePSN = ctx.ePSN + 1;
        }
        // Note: maybe we'll probably need a different TRANSMIT_EVENT processor, just for the responder side
        if(!last_packet) {
            TRANSMIT_EVENT new_event;
            new_event.wr_id = ev.wr_id;
            new_event.psn = first_psn;
            new_event.ack_req = true;
            events.add(new_event);
        }

    } else if(ev.psn < ctx.ePSN) {  // duplicate
        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    } else {                        // out-of-order: NACK
        aeth.ack = false;
        aeth.type_nack = true;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    }
}

void ReadRespProcessor(READ_RESP_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    // Note: if the response's PSN was already acked, simply ignore the event. Maybe this
    // might be important for other EPs
    if(ev.psn >= ctx.sent_packets[0].psn) {
        ctx.timer_ack_timeout.stop();

        int pkt_counter = 0;
        int psn_ack_req = ev.psn;

        for(packet in ctx.sent_packets) {
            if(packet.ack_req) {
                psn_ack_req = packet.psn;       // gets the psn of the oldest packet that requires ack
                break;
            } else if(packet.psn > ev.psn)
                break;
            pkt_counter = pkt_counter + 1;
        }

        if(psn_ack_req != ev.psn) {             // if there is a packet that requires ack before the acked packet
            TRANSMIT_EVENT new_event;
            new_event.psn = psn_ack_req;
            new_event.ack_req = ev.true;
            events.add(new_event);
        } else {
            BTHeader bth = ctx.packet_list[pkt_counter].packet.get_hdr(bth);
            addr_t addr = ctx.packet_list[pkt_counter].addr;
            mem_write(addr, ev.data, ev.psn - bth.psn, ev.data.len());
        }

        // change remove to pop
        for(int i = 0; i <= pkt_counter; i = i + 1)
            ctx.sent_packets.pop();
    
        // restart timer if we expect more responses
        for(packet in ctx.sent_packets) {
            if(packet.ack_req) {
                ctx.timer_ack_timeout.restart();
                break;
            }
        }
    }
}

void AtomicDataProcessor(ATOMIC_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    pkt_t p = new_pkt();

    AtomicAckETHeader atomicAeth;
    AETHeader aeth;
    BTHeader bth;
    if(ev.psn == ctx.ePSN) {        // expected PSN
        stream local_data;
        // New note: I noticed that ev shouldn't have a length value. Since local_data will be converted into an integer, could
        // we use something like 4 instead, to represent 4 bytes?
        local_data.mem_append(ev.raddr, ev.length);
        // Note: how should we transform a stream into an integer, to compare or add with ev.compare and ev.switch_add? (or vice-versa)
        // A: we could use int as it is
        int data = int(local_data);

        if(ev.compare == -1) {      // fetchAdd
            int result = data + ev.swap_add;
            stream result_data;
            result_data.append(byte(result));
            mem_write(ev.raddr, result_data, 0, result_data.len());
        } else {                    // compSwap
            if(ev.compare == data) {
                stream result_data;
                result_data.append(byte(ev.swap_add));
                mem_write(ev.raddr, result_data, 0, result_data.len());
            }
        }
        atomicAeth.original_data = data;

        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;

        bth.opcode = 18;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;

        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;

        udp.length = 8 + bth.len() + aeth.len() + atomicAeth.len();
        p.add_hdr({udp, bth, aeth, atomicAeth});
        packets.add(p);

        ctx.ePSN = ctx.ePSN + 1;

    } else if(ev.psn < ctx.ePSN) {  // duplicate
        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    } else {                        // out-of-order: NACK
        aeth.ack = false;
        aeth.type_nack = true;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    }   
}

void AckProcessor(ACK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.timer_ack_timeout.stop();

    int pkt_counter = 0;
    int psn_ack_req = ev.psn;

    for(packet in ctx.sent_packets) {
        if(packet.ack_req) {
            psn_ack_req = packet.psn;       // gets the psn of the oldest packet that requires ack
            break;
        } else if(packet.psn > ev.psn)
            break;
        pkt_counter = pkt_counter + 1;
    }

    for(int i = 0; i <= pkt_counter; i = i + 1)
        ctx.sent_packets.remove();

    if(psn_ack_req != ev.psn) {             // if there is a packet that requires ack before the acked packet
        TRANSMIT_EVENT new_event;
        new_event.psn = psn_ack_req;
        new_event.ack_req = ev.true;
        events.add(new_event);
    }

    for(packet in ctx.sent_packets) {
        if(packet.ack_req) {
            ctx.timer_ack_timeout.restart();
            break;
        }
    }
}

void NackProcessor(NACK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.timer_ack_timeout.stop();

    if(ev.type_nack) {
        int pkt_counter = 0;
        int psn_ack_req = ev.psn;
        int wr_id = ctx.sent_packets[0].wr_id;

        for(packet in ctx.sent_packets) {
            if(wr_id != packet.wr_id) {         // removes events that were completely acknowledged
                wr_id = packet.wr_id;
                ctx.SQ_list.remove();
            }

            if(packet.ack_req) {
                psn_ack_req = packet.psn;       // gets the psn of the oldest packet that requires ack
                break;
            } else if(packet.psn > ev.psn)
                break;
            
            pkt_counter = pkt_counter + 1;
        }

        for(int i = 0; i <= pkt_counter; i = i + 1)
            ctx.sent_packets.remove();

        TRANSMIT_EVENT new_event;
        new_event.psn = psn_ack_req;
        new_event.ack_req = ev.true;
        events.add(new_event);
        
    } else {
        TRANSMIT_EVENT new_event;
        new_event.psn = ev.psn;
        new_event.ack_req = ev.true;
        events.add(new_event);

        ctx.timer_ack_timeout.set_duration(ev.RNR_delay);
        ctx.timer_ack_timeout.start(new_event);
    }
}

// This EP removes the elements from ctx's Sending Queue and creates a completion queue event, adding it to completion queue
void RemoveSQProcessor <T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    int remove_counter = 0;

    for(event in ctx.SQ_list) {
        if(ctx.packet_list[0].wr_id != event.wr_id)
            remove_counter = remove_counter + 1;
        else
            break;
    }

    for(int i = 0; i < remove_counter; i = i + 1) {
        work_comp cqe;
        cqe.wr_id = ctx.SQ_list[i].wr_id;
        cqe.status = 0;
        // Note: could we use type(ctx.SQ_list[i]) to get the type of the event and, then, decide the opcode?
        // A: yes
        cqe.opcode = type(ctx.SQ_list[i]);
        cqe.qp_id = ctx.SQ_list[i].qp_id;
        cqe.length = ctx.SQ_list[i].data.len();
        ctx.CQ.add(byte(cqe));
        ctx.SQ_list.remove();
    }
}

void CnpCheckProcessor <T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    if(ev.ecn) {
        pkt_t p = new_pkt();

        BTHeader bth;
        bth.opcode = 129;
        bth.ack_req = false;
        bth.dest_qp = ev.qp_id;
        bth.psn = 0;

        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len();

        p.add_hdr({udp, bth});
        packets.add(p);

        CNP_CHECK new_event;
        new_event.qp_id = ev.qp_id;
        events.add(new_event);

        // New note: maybe we should have a method to check if a timer is currently triggered.
        // If it isn't currently triggered, I want to start.

        // Note: how to represent 50 microseconds? 1 = 1 second?
        // A: built in function second(1), milisecond(0), microsecond(50)
        ctx.timer_cnp.set_duration(microsecond(50));

        // A: have a timer_t type and define them in context
        ctx.timer_cnp.start(new_event);
    }
}

void CnpCheckProcessor (CNP_CHECK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    pkt_t p = new_pkt();

    BTHeader bth;
    bth.opcode = 129;
    bth.ack_req = false;
    bth.dest_qp = ev.qp_id;
    bth.psn = 0;

    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len();

    p.add_hdr({udp, bth});
    packets.add(p);

    CNP_CHECK new_event;
    new_event.qp_id = ev.qp_id;
    events.add(new_event);

    // New note: after a timer ends (e.g. 50 microseconds), if we want to restart this timer, can we use restart
    // or should we start it from ground up, with set_duration and start?
    ctx.timer_cnp.restart();
}

void CnpProcessor(CNP ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    int Rt = ctx.Rt;
    int Rc = ctx.Rc;
    int alpha = ctx.alpha;
    float g = 1/16;
    float k = 0.000055;

    ctx.Rt = Rc;
    ctx.Rc = Rc * (1 - alpha / 2);
    ctx.alpha = (1 - g) * alpha + g;

    ctx.timer_alpha.restart();
}

// Note: since alpha constantly increases as we don't receive CNP packets,
// where should we trigger the start of the timer? it should start right when the connection starts, right?
// instead of starting it in CNP processor
// A: have a way to know when the first packet is generated

void AlphaCheckProcessor(ALPHA_CHECK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    int alpha = ctx.alpha;
    float g = 1/16;

    ctx.alpha = (1 - g) * alpha;

    ctx.timer_alpha.restart();
}


// Note: this event should also be started when the connection starts

void DcqcnTimerProcessor(DCQCN_TIMER ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    ctx.T = ctx.T + 1;

    DCQCN_INCREASE new_event;
    new_event.qp_id = ev.qp_id;
    events.add(new_event);

    timer_DCQCN_counter.restart();
}

void DcqcnIncreaseProcessor(DCQCN_INCREASE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out) {
    int max;
    int min;

    if(ctx.T > ctx.BC) {
        max = ctx.T;
        min = ctx.BC;
    } else if(ctx.T < ctx.BC) {
        max = ctx.BC;
        min = ctx.T;
    } else {
        max = ctx.BC;
        min = max;
    }

    if(max < ctx.F) {
        // Fast recovery
        ctx.Rc = (ctx.Rt + Rc) / 2;
    } else if(min > ctx.F) {
        // Hyper increase
        ctx.Rt = ctx.Rai * (min - ctx.F + 1);
        ctx.Rc = (ctx.Rt + ctx.Rc) / 2;
    } else {
        // Additive increase
        ctx.Rt = ctx.Rt + ctx.Rai;
        ctx.Rc = (ctx.Rt + ctx.Rc) / 2;
    }
}

dispatch table {
    RDMA_EVENT::SEND_WQE -> {SendProcessor};
    RDMA_EVENT::WRITE_WQE -> {WriteProcessor};
    RDMA_EVENT::RECV_WQE -> {RecvProcessor};
    RDMA_EVENT::READ_WQE -> {ReadProcessor};
    RDMA_EVENT::ATOMIC_WQE -> {AtomicProcessor};
    TRANSMIT_EVENT -> {TransmitProcessor};
    RECV_DATA -> {CnpCheckProcessor, RecvDataProcessor};
    WRITE_DATA -> {CnpCheckProcessor, WriteDataProcessor};
    READ_REQ_DATA -> {CnpCheckProcessor, ReadReqProcessor};
    READ_RESP_DATA -> {ReadRespProcessor, RemoveSQProcessor};
    ATOMIC_DATA -> {CnpCheckProcessor, AtomicDataProcessor};
    ACK -> {AckProcessor, RemoveSQProcessor};
    NACK -> {NackProcessor, RemoveSQProcessor};
    CNP_CHECK -> {CnpStopProcessor};
    CNP -> {CnpProcessor};
    DCQCN_TIMER -> {DcqcnTimerProcessor};
    DCQCN_INCREASE -> {DcqcnIncreaseProcessor};
    //TX_THRESHOLD -> {txQueueProcessor};
    //TX_QUEUE_FULL -> {txQueueProcessor};
    //TX_TIMER -> {txTimerProcessor};
}
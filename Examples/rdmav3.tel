// Note: after finishing implementing rdma and revisiting tcp/quic, I really think we
// should write a documentation for the DSL


// Note: how to change the properties of the tx_module from EPs?
// A: tx_module as a parameter for EPs

// New note: i guess we should use notify (print)

struct tx_out_t {
    // New note: why also have "able"? spaces_left implicitly says if it is able or not
    bool able;
    int spaces_left;
}

pkt_sched tx_module {
    // New note: if we want to create more than one queue, should we use:
    //      tx_queue_t transmit_queue(min, max, drop)[number];
    //      or
    //      tx_queue_t transmit_queue1(...); tx_queue_t transmit_queue2(...);...
    // TODO: figure it out

    tx_queue_t transmit_queue();

    tx_out_t out;

    // New note: could we assign a value to this modele's propertes?
    int threshold = 5;

    void enqueue(pkt_t pkt) {
        // Note: add new parameter type to push (event) if we follow V2 of zoom whiteboard
        out.spaces_left = tx_queue.push(pkt);

        if(out.spaces_left > threshold) {
            out.spaces_left = out.spaces_left - 1;

        } else if(out.spaces_left <= threshold && out.spaces_left > 0){
            // New note: how to give a feedback to the programmer if it reaches the threshold?
            // If we create an event, we have no way to do it (unless we allow printing to a console or similar)
            // Instead, we could use some notify function or something, which could have a set of default phrases to print

            // New note: would it be reasonable to perhaps have the tx_queue_id in RDMA's events?
            // Because we could try to delay events whose destination is a tx_queue that is getting full
            // When we start processing the event:
            // if event.tx_id == tx_full_id
            //      delays it by placing it at the last place of the event type's queue
            
            out.spaces_left = out.spaces_left - 1;
        } else {
        }
    }

    pkt_t next_pkt() {
        // send according to the rate
    }
}

event RDMA_EVENT {
    int wr_id;
    int lkey;
    addr_t addr;
    int length;
}

event SEND_WQE : RDMA_EVENT {
    int ack_req;
}

event WRITE_WQE : RDMA_EVENT {
    int ack_req;
    int rkey;
    addr_t raddr; 
}

event READ_WQE : RDMA_EVENT {
    int rkey;
    addr_t raddr; 
}

// Note: Atomic operations use 64 bit fields
// A: bit<n> in headers
event ATOMIC_WQE : RDMA_EVENT {
    int swap_add;
    int compare;
    int rkey;
    addr_t raddr;
}

event RECV_WQE : RDMA_EVENT {

}

event TRANSMIT_EVENT {
    int qp_id;
    int wr_id;
    int psn;
    bool ack_req;
}

event ACK {
    int qp_id;
    int wr_id;
    // everything prior and including this number is received
    int psn; 
}

event NACK {
    int qp_id;
    int wr_id;
    bool type_nack;
    int psn;
    float RNR_delay;
}

event READ_REQ_DATA {
    int qp_id;
    int wr_id;
    int psn;
    addr_t raddr;
    int rkey;
    int opcode;
    bool ecn;
}

event READ_RESP_DATA {
    int qp_id;
    int wr_id;
    int psn;
    stream data;
}

event WRITE_DATA {
    int qp_id;
    int wr_id;
    int psn;
    bool ack_req;
    addr_t raddr;
    int rkey;
    int length;
    bool ecn;
}

event RECV_DATA {
    int qp_id;
    int wr_id;
    int psn;
    bool ack_req;
    stream data;
    int opcode;
    bool ecn;
}

event ATOMIC_DATA {
    int qp_id;
    int swap_add;
    int compare;
    int rkey;
    addr_t raddr;
    int length;
    bool ecn;
}

event CNP_CHECK {
    int qp_id;
}

event CNP {
    int qp_id;
}

event DCQCN_TIMER {
    int qp_id;
}

event DCQCN_INCREASE {
    int qp_id;
}

event ALPHA_CHECK {
    int qp_id;
}


sched ROCEv2Sched {

    int repeat_drop(queue_t TIMER_Queue) {
        return 0;   // always drops the first packet of the queue
    }

    queue_t<RDMA_EVENT> SEND_Queue();
    queue_t<RDMA_EVENT> RECV_Queue();
    queue_t<RATE_TIMER> TIMER_Queue(0, 1, repeat_drop);
    queue_t<ACK> ACK_Queue();
    queue_t<NACK> NACK_Queue();

    
    

    bool enqueue(event_t new_event) {
        if(type(new_event) == RDMA_EVENT::SEND_WQE ||
        type(new_event) == RDMA_EVENT::WRITE_WQE ||
        type(new_event) == RDMA_EVENT::READ_WQE) {
            SEND_Queue.push(new_event);
            return 1;
        } else if(type(new_event) == RDMA_EVENT::RECV_WQE) {
            RECV_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == RATE_TIMER) {
            TIMER_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == ACK) {
            ACK_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == NACK) {
            NACK_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == CNP) {
            CNP_Queue.push(new_event);
            return 1;
        } else if (type(new_event) == DATA) {
            DATA_Queue.push(new_event);
            return 1;
        }
        return 0;
    }

    // New: special queue (global transmit queue)

    // Note: priority
    // A: NACK / CNP (TIMER vs ACK) DATA / RDMA_EVENT
    // NACK / ACK TIMER DATA / RDMA_EVENT
    // Check round robin (deficit and weighted) vs. Aging
    event_t next_event() {

    }
}

interm_output iterm_out {
}

struct work_comp {
    int wr_id;
    int status;
    int opcode;
    int qp_id;
    int length;
}

header UDPHeader {
    int src_port;
    int dst_port;
    int length;
    int checksum;
}

header BTHeader {
    int opcode;
    bool ack_req;
    int dest_qp;
    int psn;
}

header RETHeader {
    int raddr;
    int rkey;
    int length;
}

header AETHeader {
    // Note: syndrome is represented as a binary originally. Perhaps we should have a way to represent binary numbers
    // For now, I'll split it in 2 bools and 1 int
    bool ack;           // 1 if ack, 0 if nack
    bool type_nack;     // 1 if OOO, 0 if RNR
    int credit_count;
    int MSN;
    float RNR_delay;
}

header AtomicETHeader {
    addr_t raddr;
    int rkey;
    int swap_add;
    int compare;
}

header AtomicAckETHeader {
    int original_data;
}

struct packet_list {
    pkt_t packet;
    int psn;
    bool ack_req;
    int wr_id;
    bool acked;
}

context myContext {
    int qp_id;
    int lkey;
    list<RDMA_EVENT> SQ_list;
    list<RDMA_EVENT> RQ_list;
    list<packet_list> sent_packets;
    int nPSN;
    float transport_timer;
    stream CQ;

    // Responder side
    int ePSN;
    int MSN;
    int credit_count;
    int recv_first_psn;
    int write_first_psn;

    int MTU;
    int init_sqn;
    int dest_qp;
    int src_port;
    int dst_port;

    // DCQCN
    int Rt;
    int Rc;
    int alpha;
    int byte_counter;
    int BC;
    int T;
    int F;
    int Rai;

    // New note: can we assign a initial value for the variables of the context?
    // bool first_pkt_connection = true;

    // Timers
    timer_t timer_cnp;
    timer_t timer_alpha;
    timer_t timer_DCQCN_counter
}

void SendProcessor(RDMA_EVENT::SEND_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    ctx.SQ_list.add(ev);

    if(ev.lkey == ctx.lkey) {
        stream buffer;
        buffer.mem_append(ev.addr, ev.length);
        int first_psn;

        for(int index = 0; index < ev.length; index = index + ctx.MTU) {
            pkt_t p = new_pkt();

            int data_len = ctx.MTU;
            if(index + ctx.MTU < ev.length)
                p.add_data(buffer[index : index + ctx.MTU]);
            else { // if the last packet doesn't match MTU
                p.add_data(buffer[index : ev.length]);
                data_len = env.length - index;
            }

            BTHeader bth;
            if(ev.length <= ctx.MTU) {
                bth.opcode = 4;     // only 1 packet
                last_packet = true;
                first_psn = ctx.nPSN;
            } else if(index == 0) {
                bth.opcode = 0;     // first packet
                first_psn = ctx.nPSN;
            } else if(index + ctx.MTU >= ev.length)
                bth.opcode = 2;     // last packet
            else
                bth.opcode = 1;     // middle packet
            bth.ack_req = ev.ack_req;
            bth.dest_qp = ctx.dest_qp;
            bth.psn = ctx.nPSN;
            ctx.nPSN = ctx.nPSN + 1;

            UDPHeader udp;
            udp.src_port = ctx.src_port;
            udp.dst_port = ctx.dst_port;
            udp.length = 8 + bth.len() + data_len;
            // checksum(name_of_the_algorithm)

            p.add_dr({udp, bth});

            packet_list save_packet;
            // Note: could assign work from one packet to another? or should we have a copy function?
            save_packet.packet = p;
            save_packet.psn = bth.psn;
            save_packet.ack_req = bth.ack_req;
            save_packet.wr_id = ev.wr_id;
            save_packet.acked = false;
            ctx.sent_packets.add(save_packet);
            packets.add(p);
        }
        TRANSMIT_EVENT new_event;
        new_event.wr_id = ev.wr_id;
        new_event.psn = first_psn;
        new_event.ack_req = ev.ack_req;
        events.add(new_event);
    }
}

void WriteProcessor(RDMA_EVENT::WRITE_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    ctx.SQ_list.add(ev);

    if(ev.lkey == ctx.lkey) {
        stream buffer;
        buffer.mem_append(ev.addr, ev.length);
        RETHeader reth;
        int first_psn;

        for(int index = 0; index < ev.length; index = index + ctx.MTU) {
            pkt_t p = new_pkt();

            int data_len = ctx.MTU;
            if(index + ctx.MTU < ev.length)
                p.add_data(buffer[index : index + ctx.MTU]);
            else { // if the last packet doesn't match MTU
                p.add_data(buffer[index : ev.length]);
                data_len = ev.length - index;
            }

            if(index == 0) {
                reth.addr = ev.raddr;
                reth.rkey = ev.rkey;
                reth.length = ev.length;
            }

            BTHeader bth;
            if(ev.length <= ctx.MTU) {
                bth.opcode = 10;     // only 1 packet
                first_psn = ctx.nPSN;
            } else if(index == 0) {
                bth.opcode = 6;     // first packet
                first_psn = ctx.nPSN;
            } else if(index + ctx.MTU >= ev.length)
                bth.opcode = 8;     // last packet
            else
                bth.opcode = 7;     // middle packet
            bth.ack_req = ev.ack_req;
            bth.dest_qp = ctx.dest_qp;
            bth.psn = ctx.nPSN;
            ctx.first_psn = ctx.nPSN;
            ctx.nPSN = ctx.nPSN + 1;

            UDPHeader udp;
            udp.src_port = ctx.src_port;
            udp.dst_port = ctx.dst_port;
            udp.length = 8 + bth.len() + data_len;
            if(index == 0) {
                udp.length = udp.length + eth.len();
                p.add_hdr({udp, bth, reth});
            } else
                p.add_hdr({udp, bth});

            packet_list save_packet;
            // Note: could assign work from one packet to another? or should we have a copy function?
            save_packet.packet = p;
            save_packet.psn = bth.psn;
            save_packet.ack_req = bth.ack_req;
            save_packet.wr_id = ev.wr_id;
            save_packet.acked = false;
            ctx.sent_packets.add(save_packet);
            packets.add(p);
        }
        TRANSMIT_EVENT new_event;
        new_event.wr_id = ev.wr_id;
        new_event.psn = first_psn;
        new_event.ack_req = ev.ack_req;
        events.add(new_event);
    }
}

void RecvProcessor(RDMA_EVENT::RECV_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    ctx.RQ_list.add(ev);
    ctx.credit_count = ctx.credit_cout + 1;
}

void ReadProcessor(RDMA_EVENT::READ_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    ctx.SQ_list.add(ev);

    pkt_t p = new_pkt();
    int first_psn;

    RETHeader reth;
    reth.addr = ev.raddr;
    reth.rkey = ev.rkey;
    reth.length = ev.length;

    BTHeader bth;
    bth.opcode = 12;
    bth.dest_qp = ctx.dest_qp;
    bth.psn = ctx.nPSN;
    first_psn = ctx.nPSN;
    // Note: maybe we'll need a floor/ceiling function or % to get the remainder of the division
    // A: use int()
    // A: also add % (remainder)
    ctx.nPSN = ctx.nPSN + ceil(ev.length / ctx.MTU);

    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len() + eth.len();

    p.add_hdr({udp, bth, eth});

    for(int i = 0; i < ceil(ev.length / ctx.MTU); i = i + 1) {
        packet_list save_packet;
        // Note: could assign work from one packet to another? or should we have a copy function?
        save_packet.packet = p;
        save_packet.psn = bth.psn + i;
        save_packet.ack_req = true;
        save_packet.wr_id = ev.wr_id;
        save_packet.acked = false;
        ctx.sent_packets.add(save_packet);
    }
    // make sure to not retransmit the same packet
    TRANSMIT_EVENT new_event;
    new_event.wr_id = ev.wr_id;
    new_event.psn = first_psn;
    new_event.ack_req = ev.ack_req;
    events.add(new_event);
}

void AtomicProcessor(RDMA_EVENT::READ_WQE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    ctx.SQ_list.add(ev);

    pkt_t p = new_pkt();
    int first_psn;

    AtomicETHeader aeth;
    aeth.raddr = ev.raddr;
    aeth.rkey = ev.rkey;
    aeth.swap_add = ev.swap_add;
    aeth.compare = ev.compare;
    p.add_hdr(aeth);

    BTHeader bth;
    // Note: is it ok if I consider that for fetchAdd operations aeth.compare will be -1? (Or some other value)
    // Because aeth necessarily takes compare, even if it is a fetchAdd operation
    // A: yes
    if(aeth.compare == -1)  // fetchAdd
        bth.opcode = 20;
    else                    // compSwap
        bth.opcode = 19;
    bth.dest_qp = ctx.dest_qp;
    bth.psn = ctx.nPSN;
    ctx.nPSN = ctx.nPSN + 1;

    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len() + aeth.len();

    p.add_hdr({udp, bth, aeth});
    packet_list save_packet;
    // Note: could assign work from one packet to another? or should we have a copy function?
    save_packet.packet = p;
    save_packet.psn = bth.psn + i;
    save_packet.ack_req = true;
    save_packet.wr_id = ev.wr_id;
    save_packet.acked = false;
    ctx.sent_packets.add(save_packet);

    TRANSMIT_EVENT new_event;
    new_event.wr_id = ev.wr_id;
    new_event.psn = ctx.nPSN - 1;
    new_event.ack_req = true;
    events.add(new_event);
}

void TransmitProcessor(TRANSMIT_EVENT ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx, rate_param rate) {

    int sent_packets = 0;
    bool last_packet = true;
    for(packet in ctx.packet_list) {
        if(packet.psn >= ctx.first_psn) {
            sent_packets = sent_packets + 1;
            packets.add(packet);

            // Note: increase byte counter for DCQCN
            ctx.byte_counter = packet.len();
            if(ctx.byte_counter > ctx.B) {
                ctx.byte_counter = 0;
                ctx.BC = ctx.BC + 1;

                DCQCN_INCREASE new_event;
                new_event.qp_id = ev.qp_id;
                events.add(new_event);
            }
        }

        // Note: create a condition to break this loop if the number of packets sent reach a certain rate
        if(sent_packets ... something_rate) {
            last_packet = false;
            break;
        }
    }

    if(!last_packet) {
        TRANSMIT_EVENT new_event;
        new_event.wr_id = ev.wr_id;
        new_event.psn = ev.psn + sent_packets;
        new_event.ack_req
        events.add(new_event);
    }

    if(ev.ack_req) {
        timer.set_duration(ctx.transport_timer);
        timer.start(ev);
    }
}

void RecvDataProcessor(RECV_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    pkt_t p = new_pkt();

    if(ctx.credit_count > 0) {
        if(ev.psn == ctx.ePSN && ev.opcode == 0 || ev.opcode == 4) {        // saves the psn of send operation's first packet
            ctx.recv_first_psn = ev.psn;
        }
        AETHeader aeth;
        if(ev.psn <= ctx.ePSN) {        // duplicate or expected PSN
            aeth.ack = true;
            aeth.MSN = ctx.MSN;
            if(ev.psn == ctx.ePSN && ev.opcode == 2 || ev.opcode == 4)        // last or only packet
                ctx.credit_count = ctx.credit_count - 1;
            aeth.credit_count = ctx.credit_count;
        } else {                        // out-of-order: NACK
            aeth.ack = false;
            aeth.type_nack = true;
        }
        BTHeader bth;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});

        if(ev.psn == ctx.ePSN) {
            ctx.ePSN = ctx.ePSN + 1;
            addr_t addr = ctx.RQ_list[0].addr;
            mem_write(addr, ev.data, ev.psn - ctx.recv_first_psn, ev.data.len());

            if(ev.opcode == 2 || ev.opcode == 4) {
                work_comp cqe;
                cqe.wr_id = ev.wr_id;
                cqe.status = 0;
                cqe.opcode = 6;
                cqe.qp_id = ev.qp_id;
                cqe.length = ev.data.len();
                ctx.CQ.add(byte(cqe));

                // Note: actually, we don't have an operation to remove elements from a list
                // Maybe we could use the following sintax, which always remove the first element of the list
                // A: use pop
                // Note: we are currently using add to add something to the end of a list. Should we start using push, then?
                // A: yes (add/remove or push/pop for packets, lists and streams)
                // check vectors
                ctx.RQ_list.pop();
            }
        }
        if(ev.ack_req || !aeth.ack)     // sends packet if requires ack or is a nack
            packets.add(p);

        

    } else {                // there are no recv events posted
        AETHeader aeth;
        aeth.ack = false;
        aeth.type_nack = false;
        BTHeader bth;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    }
}

void WriteDataProcessor(WRITE_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    if(ev.psn == ctx.ePSN && ev.opcode == 6 || ev.opcode == 10) {        // saves the psn of write operation's first/only packet
        ctx.write_first_psn = ev.psn;
    }
    AETHeader aeth;
    if(ev.psn <= ctx.ePSN) {        // duplicate or expected PSN
        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;
    } else {                        // out-of-order: NACK
        aeth.ack = false;
        aeth.type_nack = true;
    }
    BTHeader bth;
    bth.opcode = 17;
    bth.dest_qp = ctx.dest_qp;
    bth.psn = ctx.ePSN;
    UDPHeader udp;
    udp.src_port = ctx.src_port;
    udp.dst_port = ctx.dst_port;
    udp.length = 8 + bth.len() + aeth.len();
    p.add_hdr({udp, bth, aeth});

    if(ev.psn == ctx.ePSN) {
        ctx.ePSN = ctx.ePSN + 1;
        addr_t addr = ctx.RQ_list[0].addr;
        mem_write(addr, ev.data, ev.psn - ctx.write_first_psn, ev.data.len());
    }
    if(ev.ack_req || !aeth.ack)     // sends packet if requires ack or is a nack
        packets.add(p);
}

void ReadReqProcessor(READ_REQ_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    pkt_t p = new_pkt();

    AETHeader aeth;
    BTHeader bth;
    if(ev.psn == ctx.ePSN) {        // expected PSN
        stream buffer;
        buffer.mem_append(ev.raddr, ev.length);
        bool last_packet = false;

        for(int index = 0; index < ctx.length; index = index + ctx.MTU) {
            int data_len = ctx.MTU;
            if(index + ctx.MTU < ev.length)
                p.add_data(buffer[index : index + ctx.MTU]);
            else { // if the last packet doesn't match MTU
                p.add_data(buffer[index : ev.length]);
                data_len = ev.length - index;
            }
            aeth.ack = true;
            aeth.MSN = ctx.MSN;
            aeth.credit_count = ctx.credit_count;
            if(ev.length <= ctx.MTU) {
                bth.opcode = 16;     // only 1 packet
                last_packet = true;
            } else if(index == 0)
                bth.opcode = 13;     // first packet
            else if(index + ctx.MTU >= ev.length) {
                bth.opcode = 15;     // last packet
                last_packet = true;
            } else
                bth.opcode = 14;     // middle packet
            bth.dest_qp = ctx.dest_qp;
            bth.psn = ctx.ePSN;
            UDPHeader udp;
            udp.src_port = ctx.src_port;
            udp.dst_port = ctx.dst_port;
            if(bth.opcode != 14) {
                udp.length = 8 + bth.len() + aeth.len() + data_len;
                p.add_hdr({udp, bth, aeth});
            }
            else {
                udp.length = 8 + bth.len() + data_len;
                p.add_hdr({udp, bth});
            }

            // create a EP for the responder side (transmit/retransmit)

            packets.add(p);
            ctx.ePSN = ctx.ePSN + 1;
        }
        // Note: maybe we'll probably need a different TRANSMIT_EVENT processor, just for the responder side
        if(!last_packet) {
            TRANSMIT_EVENT new_event;
            new_event.wr_id = ev.wr_id;
            new_event.psn = first_psn;
            new_event.ack_req = true;
            events.add(new_event);
        }

    } else if(ev.psn < ctx.ePSN) {  // duplicate
        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    } else {                        // out-of-order: NACK
        aeth.ack = false;
        aeth.type_nack = true;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    }
}

void ReadRespProcessor(READ_RESP_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    // Note: if the response's PSN was already acked, simply ignore the event. Maybe this
    // might be important for other EPs
    if(ev.psn >= ctx.sent_packets[0].psn) {
        timer.stop();

        int pkt_counter = 0;
        int psn_ack_req = ev.psn;

        for(packet in ctx.sent_packets) {
            if(packet.ack_req) {
                psn_ack_req = packet.psn;       // gets the psn of the oldest packet that requires ack
                break;
            } else if(packet.psn > ev.psn)
                break;
            pkt_counter = pkt_counter + 1;
        }

        if(psn_ack_req != ev.psn) {             // if there is a packet that requires ack before the acked packet
            TRANSMIT_EVENT new_event;
            new_event.psn = psn_ack_req;
            new_event.ack_req = ev.true;
            events.add(new_event);
        } else {
            BTHeader bth = ctx.packet_list[pkt_counter].packet.get_hdr(bth);
            addr_t addr = ctx.packet_list[pkt_counter].addr;
            mem_write(addr, ev.data, ev.psn - bth.psn, ev.data.len());
        }

        // change remove to pop
        for(int i = 0; i <= pkt_counter; i = i + 1)
            ctx.sent_packets.pop();
    
        // restart timer if we expect more responses
        for(packet in ctx.sent_packets) {
            if(packet.ack_req) {
                timer.restart();
                break;
            }
        }
    }
}

void AtomicDataProcessor(ATOMIC_DATA ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    pkt_t p = new_pkt();

    AtomicAckETHeader atomicAeth;
    AETHeader aeth;
    BTHeader bth;
    if(ev.psn == ctx.ePSN) {        // expected PSN
        stream local_data;
        local_data.mem_append(ev.raddr, ev.length);
        // Note: how should we transform a stream into an integer, to compare or add with ev.compare and ev.switch_add? (or vice-versa)
        // A: we could use int as it is
        int data = int(local_data);

        if(ev.compare == -1) {      // fetchAdd
            int result = data + ev.swap_add;
            stream result_data;
            result_data.append(byte(result));
            mem_write(ev.raddr, result_data, 0, result_data.len());
        } else {                    // compSwap
            if(ev.compare == data) {
                stream result_data;
                result_data.append(byte(ev.swap_add));
                mem_write(ev.raddr, result_data, 0, result_data.len());
            }
        }
        atomicAeth.original_data = data;

        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;

        bth.opcode = 18;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;

        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;

        udp.length = 8 + bth.len() + aeth.len() + atomicAeth.len();
        p.add_hdr({udp, bth, aeth, atomicAeth});
        packets.add(p);

        ctx.ePSN = ctx.ePSN + 1;

    } else if(ev.psn < ctx.ePSN) {  // duplicate
        aeth.ack = true;
        aeth.MSN = ctx.MSN;
        aeth.credit_count = ctx.credit_count;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    } else {                        // out-of-order: NACK
        aeth.ack = false;
        aeth.type_nack = true;
        bth.opcode = 17;
        bth.dest_qp = ctx.dest_qp;
        bth.psn = ctx.ePSN;
        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len() + aeth.len();
        p.add_hdr({udp, bth, aeth});
        packets.add(p);
    }   
}

// Note: maybe we won't even need a separate ACK event/processor for atomic acks, since it does the same thing as
// a common ack, but it has the original_data value from AtomicAETH. And this value doesn't seem to matter much
// Maybe it's implementation-specific
void AtomicACKProcessor(ATOMIC_ACK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
}

void AckProcessor(ACK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    timer.stop();

    int pkt_counter = 0;
    int psn_ack_req = ev.psn;

    for(packet in ctx.sent_packets) {
        if(packet.ack_req) {
            psn_ack_req = packet.psn;       // gets the psn of the oldest packet that requires ack
            break;
        } else if(packet.psn > ev.psn)
            break;
        pkt_counter = pkt_counter + 1;
    }

    for(int i = 0; i <= pkt_counter; i = i + 1)
        ctx.sent_packets.remove();

    if(psn_ack_req != ev.psn) {             // if there is a packet that requires ack before the acked packet
        TRANSMIT_EVENT new_event;
        new_event.psn = psn_ack_req;
        new_event.ack_req = ev.true;
        events.add(new_event);
    }

    for(packet in ctx.sent_packets) {
        if(packet.ack_req) {
            timer.restart();
            break;
        }
    }
}

void NackProcessor(NACK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    timer.stop();

    if(ev.type_nack) {
        int pkt_counter = 0;
        int psn_ack_req = ev.psn;
        int wr_id = ctx.sent_packets[0].wr_id;

        for(packet in ctx.sent_packets) {
            if(wr_id != packet.wr_id) {         // removes events that were completely acknowledged
                wr_id = packet.wr_id;
                ctx.SQ_list.remove();
            }

            if(packet.ack_req) {
                psn_ack_req = packet.psn;       // gets the psn of the oldest packet that requires ack
                break;
            } else if(packet.psn > ev.psn)
                break;
            
            pkt_counter = pkt_counter + 1;
        }

        for(int i = 0; i <= pkt_counter; i = i + 1)
            ctx.sent_packets.remove();

        TRANSMIT_EVENT new_event;
        new_event.psn = psn_ack_req;
        new_event.ack_req = ev.true;
        events.add(new_event);
        
    } else {
        TRANSMIT_EVENT new_event;
        new_event.psn = ev.psn;
        new_event.ack_req = ev.true;
        events.add(new_event);

        timer.set_duration(ev.RNR_delay);
        timer.start(new_event);
    }
}

// Note: we could have a single EP to remove elements from SQ if the parameter for the event wasn't required
void RemoveSQProcessor <T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    int remove_counter = 0;

    for(event in ctx.SQ_list) {
        if(ctx.packet_list[0].wr_id != event.wr_id)
            remove_counter = remove_counter + 1;
        else
            break;
    }

    for(int i = 0; i < remove_counter; i = i + 1) {
        work_comp cqe;
        cqe.wr_id = ctx.SQ_list[i].wr_id;
        cqe.status = 0;
        // Note: could we use type(ctx.SQ_list[i]) to get the type of the event and, then, decide the opcode?
        // A: yes
        //cqe.opcode = 6;
        cqe.qp_id = ctx.SQ_list[i].qp_id;
        cqe.length = ctx.SQ_list[i].data.len();
        ctx.CQ.add(byte(cqe));
        ctx.SQ_list.remove();
    }
}

void CnpCheckProcessor <T>(T ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    if(ev.cnp) {
        pkt_t p = new_pkt();

        BTHeader bth;
        bth.opcode = 129;
        bth.ack_req = false;
        bth.dest_qp = ev.qp_id;
        bth.psn = 0;

        UDPHeader udp;
        udp.src_port = ctx.src_port;
        udp.dst_port = ctx.dst_port;
        udp.length = 8 + bth.len();

        p.add_hdr({udp, bth});
        packets.add(p);

        CNP_CHECK new_event;
        new_event.qp_id = ev.qp_id;
        events.add(new_event);

        // Note: how to represent 50 microseconds? 1 = 1 second?
        // A: built in function second(1), milisecond(0), microsecond(50)
        timer_cnp.set_duration(microsecond(50));

        // A: have a timer_t type and define them in context
        timer_cnp.start(new_event);
    }
}

void CnpProcessor(CNP ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    int Rt = ctx.Rt;
    int Rc = ctx.Rc;
    int alpha = ctx.alpha;
    float g = 1/16;
    float k = 0.000055;

    ctx.Rt = Rc;
    ctx.Rc = Rc * (1 - alpha / 2);
    ctx.alpha = (1 - g) * alpha + g;

    timer_alpha.restart();
}

// Note: since alpha constantly increases as we don't receive CNP packets,
// where should we trigger the start of the timer? it should start right when the connection starts, right?
// instead of starting it in CNP processor
// A: have a way to know when the first packet is generated

void AlphaCheckProcessor(ALPHA_CHECK ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    int alpha = ctx.alpha;
    float g = 1/16;

    ctx.alpha = (1 - g) * alpha;

    timer_alpha.restart();
}


// Note: this event should also be started when the connection starts

void DcqcnTimerProcessor(DCQCN_TIMER ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    ctx.T = ctx.T + 1;

    DCQCN_INCREASE new_event;
    new_event.qp_id = ev.qp_id;
    events.add(new_event);

    timer_DCQCN_counter.restart();
}

void DcqcnIncreaseProcessor(DCQCN_INCREASE ev, myContext ctx, list<event_t> events, list<pkt_t> packets, interm_out out, tx_module tx) {
    int max;
    int min;

    if(ctx.T > ctx.BC) {
        max = ctx.T;
        min = ctx.BC;
    } else if(ctx.T < ctx.BC) {
        max = ctx.BC;
        min = ctx.T;
    } else {
        max = ctx.BC;
        min = max;
    }

    if(max < ctx.F) {
        // Fast recovery
        ctx.Rc = (ctx.Rt + Rc) / 2;
    } else if(min > ctx.F) {
        // Hyper increase
        ctx.Rt = ctx.Rai * (min - ctx.F + 1);
        ctx.Rc = (ctx.Rt + ctx.Rc) / 2;
    } else {
        // Additive increase
        ctx.Rt = ctx.Rt + ctx.Rai;
        ctx.Rc = (ctx.Rt + ctx.Rc) / 2;
    }
}

dispatch table {
    RDMA_EVENT::SEND_WQE -> {SendProcessor};
    RDMA_EVENT::WRITE_WQE -> {WriteProcessor};
    RDMA_EVENT::RECV_WQE -> {RecvProcessor};
    RDMA_EVENT::READ_WQE -> {ReadProcessor};
    RDMA_EVENT::ATOMIC_WQE -> {AtomicProcessor};
    TRANSMIT_EVENT -> {TransmitProcessor};
    RECV_DATA -> {CnpCheckProcessor, RecvDataProcessor};
    WRITE_DATA -> {CnpCheckProcessor, WriteDataProcessor};
    READ_REQ_DATA -> {CnpCheckProcessor, ReadReqProcessor};
    READ_RESP_DATA -> {ReadRespProcessor, RemoveSQProcessor};
    ATOMIC_DATA -> {CnpCheckProcessor, AtomicDataProcessor};
    ACK -> {AckProcessor, RemoveSQProcessor};
    NACK -> {NackProcessor, RemoveSQProcessor};
    CNP_CHECK -> {CnpCheckProcessor};
    CNP -> {CnpProcessor};
    DCQCN_TIMER -> {DcqcnTimerProcessor};
    DCQCN_INCREASE -> {DcqcnIncreaseProcessor};
}